#GIT COMMANDS
# simple aliases
# alias gibr='git branch';
alias gime='git merge master';
alias gipu='git pull';  #down <==
alias gist='git status';

# complex aliases
# git upstream
giup () {
    #If first variable is null, don't go forward
    if [[ -z "$1" ]]; then
        echo "COMMAND INVALID! MUST HAVE AT LEAST ONE VARIABLE!";
    else
        #If second variable is null
        if [[ -z "$2" ]]; then
            #Set the second variable equal to the first one
            set $1 $1;
        fi
        git branch --set-upstream-to=origin/$1 $2;
    fi
}
# git checkout
gico () {
    #If first variable is null, checkout master.
    if [[ -z "$1" ]]; then
        git checkout master;
        git pull;
    else
        git checkout $1;
    fi
}
# git diff
gidf () {
    action="git diff";
    if [[ -z "$1" ]]; then
        echo "$action;";
        $action;
    else
        action=$(transformGitFileAction $1);

        echo "$action;";
        $action;
    fi
}

# git add
giad () {
    action="git add";
    if [[ -z "$1" ]]; then
        echo "COMMAND INVALID! MUST HAVE AT LEAST ONE VARIABLE!";
    else
        action=$(transformGitFileAction $1);

        echo "$action;";
        $action;
    fi
}

transformGitFileAction () {
    hasExtension="(\.\w?)";
    if [[ $1 =~ $hasExtension ]]; then
        action="$action *$1"
    else
        action="$action *$1*";
    fi

    echo "$action";
}

# git push #up   ==>
gipx () {
    action="git pull";
    echo "$action;";
    $action;

    action="git push";
    echo "$action;";
    $action;
}

# GIT BRANCH 2.0
gibr () {
    action='';
    pointer='';

    # If we don't have any parameter, I assume we just want to see local branches
    if [[ -z "$1" ]]; then
        action='branch';
    else
        isParameter="-\w+";

        # Now, if I do have parameters, I will evaluate them one by one (IN ORDER, PLEASE)
        for var in "$@"
        do
            # And now I check if current variable is a parameter or not
            if [[ $var =~ $isParameter ]]; then
                # If it's a parameter, I check if my own action is empty so I won't override it
                if [[ -z $action ]]; then
                    # If it's -new, we create and move to the branch
                    if [[ $var = '-new' ]]; then
                        action='checkout -b';
                    # If it's -delete, we evaluate further
                    elif [[ $var = '-delete' ]]; then
                        action_where='';

                        # Now I run the loop again to check for a more specific action
                        for deleteVar in "$@"
                        do
                            # If it's -local, I set -D (for now) for deleting even unmerged branches
                            if [[ $deleteVar = '-local' ]]; then
                                action_where='-D';
                                action="branch $action_where";
                            # If it's -origin, I set the action to use push --delete from the remote server
                            elif [[ $deleteVar = '-origin' ]]; then
                                action_where="origin --delete";
                                action="push $action_where";
                            fi
                        done

                        # If there is no specific information about how to delete, I assume it's local -D (for now)
                        if [[ -z $action ]]; then
                            action_where='-D';
                            action="branch $action_where";
                        fi
                    fi
                fi
            # If it's not a parameter, then its a pointer to a branch
            elif [[ -z $pointer ]]; then
                if [[ -z $action ]]; then
                    action='checkout';
                fi
                pointer=" $var";
            fi
        done

        # Now I evaluate if it's to delete or not with RegEx
        isDelete="(-D|--delete)";
        if [[ $action =~ $isDelete ]]; then
            # If it's to delete, then I check if it's local or not
            isLocal="(-D)";
            if [[ $action =~ $isLocal ]]; then
                # And not I show the appropriated message for local delete
                read -p "Are you sure you want to remove$pointer locally?" -n 1 -r
                echo    # (optional) move to a new line
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    true;
                else
                    return;
                fi
            else
                # And not I show the appropriated message for REMOTE delete
                read -p "Are you REALLY sure you want to remove$pointer FROM REMOTE?" -n 1 -r
                echo    # (optional) move to a new line
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    true;
                else
                    return;
                fi
            fi
        fi
    fi

    echo "git $action$pointer;";
    git $action$pointer;
}