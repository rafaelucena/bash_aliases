#GIT COMMANDS
# simple aliases
# alias gibr='git branch';
alias gime='git merge master';
alias gipu='git pull';  #down <==
alias gist='git status';

# complex aliases

# git commit
# COLOR FIXED
# SUBFUNCTIONS FIXED
# LOCAL VARIABLES FIXED
# PRINT COMMAND FIXED
# COMMENTS @TODO
gicm () {
    local action='commit -m';
    local pointer="\"$@\"";

    if [[ -n $@ ]]; then
        __gi_print_execute;
    else
        echo "Usage: gicm <commit message with quotes>";
    fi
}

# git diff
# COLOR FIXED
# SUBFUNCTIONS FIXED
# LOCAL VARIABLES FIXED
# PRINT COMMAND FIXED
# COMMENTS @TODO
gidf () {
    local action='diff';
    local pointer='';

    if [[ -n "$1" ]]; then
        pointer=$(__gi_file_extension_modifier $1);
    fi

    __gi_print_execute;
}

# git add
# COLOR FIXED
# SUBFUNCTIONS FIXED
# LOCAL VARIABLES FIXED
# PRINT COMMAND FIXED
# COMMENTS @TODO
giad () {
    local action='add';
    local pointer='';

    if [[ -n "$1" ]]; then
        pointer=$(__gi_file_extension_modifier $1);
    else
        echo "COMMAND INVALID! MUST HAVE AT LEAST ONE VARIABLE!";
    fi

    __gi_print_execute;
}

# git push #up   ==>
# COLOR FIXED
# SUBFUNCTIONS FIXED
# LOCAL VARIABLES FIXED
# PRINT COMMAND FIXED
gipx () {
    local action='';

    action='pull';
    __gi_print_execute;

    action='push';
    __gi_print_execute;
}

# GIT BRANCH 3.0
# COLOR FIXED
# SUBFUNCTIONS FIXED
# LOCAL VARIABLES FIXED
# PRINT COMMAND FIXED
# COMMENTS @TODO
gibr () {
    local action='';
    local pointer='';
    local question='';

    # If we don't have any parameter, I assume we just want to see local branches
    if [[ -z $1 ]]; then
        action='branch';
    else
        __gi_br_set_command $@;

        __gi_br_set_question;

        if [[ -n "$question" ]]; then
            local answer='';

            read -p "$(echo -e $question)" -n 1 -r answer
            echo    # (optional) move to a new line
            if [[ $answer =~ ^[Yy]$ ]]; then
                true;
            else
                return;
            fi
        fi
    fi

    __gi_print_execute;
}

gitest () {
    local error='';
    local question='';
    local action='';
    local pointer='';

    local firstAction='';
    local secondAction='';
    local limitAction=2;

    local firstPointer='';
    local secondPointer='';
    local limitPointer=1;

    # First we fill the variables according to the information received
    __gi_global_filter_input "${@}";

    if [[ -n "${error}" ]]; then
        # @TODO - optimize errors
        echo "${error}";
    else
        case "${firstAction}" in
            # Creating a new branch
            '-n'|'-new')
                # Only ${firstPointer} is necessary here
                __gi_br_action_new "${firstPointer}";;
            *)
                # @TODO - gibr without parameters will output usage
                echo 'eita';;
        esac

        if [[ -n "${error}" ]]; then
            # @TODO - optimize errors
            echo "${error}";
        else
            # If no errors were found, we keep on to execution passing only the usable variables
            __gi_global_print_execute "${action}" "${pointer}";
        fi
    fi
}

gotomap () {
    basepath=${PWD##*/};
    basepath=${basepath,,};
    fullpath=${PWD};

    tag="<local name=\"$basepath\" path=\"$fullpath\"></local>"
    echo "$tag";
}