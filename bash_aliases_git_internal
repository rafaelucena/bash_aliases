#
__print_command () {
    local print_command='';

    if [[ -n $pointer ]]; then
        print_command="$(dye cyan)$1$(dye undye) $(dye red)$action$(dye undye) $(dye orange)$pointer$(dye undye);";
    else
        print_command="$(dye cyan)$1$(dye undye) $(dye green)$action$(dye undye);";
    fi

    echo -e "$print_command";
}

__run_command () {
    local command=$1;

    if [[ -n ${pointer} ]]; then
        ${command} ${action} "${pointer}";
    else
        ${command} ${action};
    fi
}

#GIT INTERNAL COMMANDS
__gi_print_execute () {
    if [[ -n $action ]]; then
        __print_command 'git';

        __run_command 'git';
    fi
}

__gi_file_extension_modifier () {
    local hasExtension='(\.\w?)';
    local pointer='';

    if [[ $1 =~ $hasExtension ]]; then
        pointer="*$1"
    else
        pointer="*$1*";
    fi

    echo "$pointer";
}

##GIBR FUNCTIONS
__gi_br_set_command () {
    isParameter='^-\w+';

    # Now, if I do have parameters, I will evaluate them one by one (IN ORDER, PLEASE)
    for var in "$@"; do
        # And now I check if current variable is a parameter or not
        if [[ $var =~ $isParameter ]]; then
            # If it's a parameter, I check if my own action is empty so I won't override it
            if [[ -z $action ]]; then
                __gi_br_action $@;
            fi
        # If it's not a parameter, then its a pointer to a branch
#        elif [[ -z $pointer ]]; then
        else
            __gi_br_pointer;
        fi
    done
}

__gi_br_set_question () {
    # Now I evaluate if it's to delete or not with RegEx
    local isDelete='(-D|--delete)';

    if [[ $action =~ $isDelete ]]; then
        # If it's to delete, then I check if it's local or not
        local isDeleteLocal='(-D)';

        if [[ $action =~ $isDeleteLocal ]]; then
            # And now I set the appropriated message for local delete
            question="Are you sure you want to remove $(dye orange)$pointer$(dye undye) locally?";
        else
            # And now I set the appropriated message for REMOTE delete
            question="Are you REALLY sure you want to remove $(dye red)$pointer$(dye undye) FROM REMOTE?";
        fi
    fi
}

__gi_br_pointer() {
    if [[ -z $action ]]; then
        action='checkout';
    fi

    pointer="$var";
}

__gi_br_action() {
    # If it's -new, we create and move to the branch
    local isActionNew='(-new$|-n$)';
    local isActionList='((-l$|-a$|-r$)|(-local$|-all$|-remote$))';
    local isActionDelete='((-d$|-D$)|(-delete$|-DELETE$))';

    if [[ $var =~ $isActionNew ]]; then
        action='checkout -b';
    # If it's -delete, we evaluate further
    elif [[ $var =~ $isActionList ]]; then
        __gi_br_action_list $var;
    elif [[ $var =~ $isActionDelete ]]; then
        __gi_br_action_delete $@;
    fi
}

__gi_br_action_list () {
   local isActionListLocal='((-l$|-local$))';
   local isActionListRemote='((-r$|-remote$))';
   local isActionListAll='((-a$|-all$))';

   action='branch';

   if [[ $1 =~ $isActionListLocal ]]; then
       pointer='-l';
   elif [[ $1 =~ $isActionListRemote ]]; then
       pointer='-r';
   elif [[ $1 =~ $isActionListAll ]]; then
       pointer='-a';
   fi
}

__gi_br_action_delete () {
    # Now I run the loop again to check for a more specific action

    # If it's -local, I set -D (for now) for deleting even unmerged branches
    local isLocal='(-l$|-local$)';
    local isRemote='((-o$|-r$)|(-origin$|-remote$))';

    for deleteVar in "$@"; do
        if [[ $deleteVar =~ $isLocal ]]; then
            action='branch -D';
        # If it's -origin, I set the action to use push --delete from the remote server
        elif [[ $deleteVar =~ $isRemote ]]; then
            action='push origin --delete';

            # If it's to delete remotely, I fill the current branch, just in case
            pointer=$(get_git_branch);
        fi
    done

    # If there is no specific information about how to delete, I assume it's local -D (for now)
    if [[ -z $action ]]; then
        action='branch -D';
    fi
}

############### KEEPING EVERYTHING BEYOND THIS POINT
## GI GLOBAL
__gi_global_filter_input () {
    local isParameter='^-\w+';

    local countActions=0;
    local countPointers=0;

    # Now, if I do have parameters, I will evaluate them and allocate into specific variables
    for input in "${@}"; do
        # And now I check if current variable is a parameter or not
        if [[ "${input}" =~ ${isParameter} ]]; then
            ((countActions++));

            # If it's a parameter, I check if my own action is empty so I won't override it
            if [[ -z "${firstAction}" ]]; then
                firstAction="${input}";
            elif [[ -z "${secondaryAction}" ]]; then
                secondAction="${input}";
            fi
        # If it's not a parameter, then its a pointer to a branch
        else
            ((countPointers++));

            if [[ -z "${firstPointer}" ]]; then
                firstPointer="${input}";
            elif [[ -z "${secondPointer}" ]]; then
                secondPointer="${input}";
            fi
        fi

        if [[ "${countActions}" -gt "${limitAction}" || "${countPointers}" -gt "${limitPointer}" ]]; then
            if [[ "${countActions}" -gt "${limitAction}" && "${countPointers}" -gt "${limitPointer}" ]]; then
                error='Too many arguments';
            elif [[ "${countActions}" -gt "${limitAction}" ]]; then
                error='Too many parameters';
            else
                error='Too many pointers';
            fi
            break;
        fi
    done

    echo "Actions: ${countActions}, Pointers: ${countPointers}, Error: ${error}";
    #echo "$firstPointer";
}

__gi_global_print_execute () {
    if [[ -n "${1}" ]]; then
        __global_print 'git' "${1}" "${2}";

        #__global_execute 'git' "${1}" "${2}";
    fi
}

__global_print () {
    local print_command='';

    if [[ -n "${3}" ]]; then
        print_command="$(dye cyan)${1}$(dye undye) $(dye red)${2}$(dye undye) $(dye orange)${3}$(dye undye);";
    else
        print_command="$(dye cyan)${1}$(dye undye) $(dye green)${2}$(dye undye);";
    fi

    echo -e "${print_command}";
}

__global_execute () {
    local command="${1}";

    if [[ -n "${3}" ]]; then
        "${command}" ${2} "${3}";
    else
        "${command}" ${2};
    fi
}

## GI_BR FUNCTIONS 3.0
__gi_br_action_new () {
    if [[ -n "${1}" ]]; then
        action='checkout -b';
        pointer="${1}";
    else
        error='missing pointer';
    fi
}