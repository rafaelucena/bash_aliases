#
__print_command () {
    local print_command='';

    if [[ -n $pointer ]]; then
        print_command="$(dye cyan)$1$(dye undye) $(dye red)$action$(dye undye) $(dye orange)$pointer$(dye undye);";
    else
        print_command="$(dye cyan)$1$(dye undye) $(dye green)$action$(dye undye);";
    fi

    echo -e "$print_command";
}

__run_command () {
    local command=$1;

    if [[ -n ${pointer} ]]; then
        ${command} ${action} "${pointer}";
    else
        ${command} ${action};
    fi
}

#GIT INTERNAL COMMANDS'
__gi_print_execute () {
    if [[ -n $action ]]; then
        __print_command 'git';

        __run_command 'git';
    fi
}

__gi_file_extension_modifier () {
    local hasExtension='(\.\w?)';
    local pointer='';

    if [[ $1 =~ $hasExtension ]]; then
        pointer="*$1"
    else
        pointer="*$1*";
    fi

    echo "$pointer";
}

############### KEEPING EVERYTHING BEYOND THIS POINT
## GI GLOBAL
__gi_global_filter_input () {
    local isParameter='^-\w+';

    local countActions=0;
    local countPointers=0;

    #INHERITED
    local limitAction="${limitAction}";
    local limitPointer="${limitPointer}";

    # Now, if I do have parameters, I will evaluate them and allocate into specific variables
    for input in "${@}"; do
        # And now I check if current variable is a parameter or not
        if [[ "${input}" =~ ${isParameter} ]]; then
            ((countActions++));

            # If it's a parameter, I check if my own action is empty so I won't override it
            if [[ -z "${firstAction}" ]]; then
                firstAction="${input}";
            elif [[ -z "${secondaryAction}" ]]; then
                secondAction="${input}";
            fi
        # If it's not a parameter, then its a pointer to a branch
        else
            ((countPointers++));

            if [[ -z "${firstPointer}" ]]; then
                firstPointer="${input}";
            elif [[ -z "${secondPointer}" ]]; then
                secondPointer="${input}";
            fi
        fi

        if [[ "${countActions}" -gt "${limitAction}" || "${countPointers}" -gt "${limitPointer}" ]]; then
            if [[ "${countActions}" -gt "${limitAction}" && "${countPointers}" -gt "${limitPointer}" ]]; then
                error='Too many arguments';
            elif [[ "${countActions}" -gt "${limitAction}" ]]; then
                error='Too many parameters';
            else
                error='Too many pointers';
            fi
            break;
        fi
    done

    #echo "Actions: ${countActions}, Pointers: ${countPointers}, Error: ${error}";
    #echo "$firstPointer";
}

__gi_global_print_execute () {
    if [[ -n "${1}" ]]; then
        __global_print 'git' "${1}" "${2}";

        # for now let's assume that anything sent as a third parameter is the debug trigger
        if [[ -z "${3}" ]]; then
            __global_execute 'git' "${1}" "${2}";
        fi
    fi
}

__global_print () {
    local print_command='';

    if [[ -n "${3}" ]]; then
        print_command="$(dye cyan)${1}$(dye undye) $(dye red)${2}$(dye undye) $(dye orange)${3}$(dye undye);";
    else
        print_command="$(dye cyan)${1}$(dye undye) $(dye green)${2}$(dye undye);";
    fi

    echo -e "${print_command}";
}

__global_execute () {
    local command="${1}";

    if [[ -n "${3}" ]]; then
        "${command}" ${2} "${3}";
    else
        "${command}" ${2};
    fi
}

## GI_BR FUNCTIONS 3.0
__gi_br_action_setup () {
    case "${firstAction}" in
        # Creating a new branch
        '-n'|'-new')
            # Only ${firstPointer} is necessary here
            __gi_br_action_new "${firstPointer}";
            ;;
        # Listing branches
        '-l'|'-r'|'-a'|'-local'|'-list'|'-remote'|'-all')
            # Only ${firstAction} is necessary here
            __gi_br_action_list_up "${firstAction}";
            ;;
        '-d'|'-del'|'-delete')
            # ${firstAction} and ${firstPointer} are necessary here
            __gi_br_action_delete_up "${secondAction}" "${firstPointer}";
            ;;
        *)
            # Checking out branches
            if [[ -z "${firstAction}" && -n "${firstPointer}" ]]; then
                # Only ${firstPointer} is necessary here
                __gi_br_action_checkout "${firstPointer}";
            else
                # @TODO - gibr without parameters will output usage
                echo 'eitas';
            fi

            ;;
    esac
}

__gi_br_action_new () {
    if [[ -n "${1}" ]]; then
        action='checkout -b';
        pointer="${1}";
    else
        error='missing pointer';
    fi
}

__gi_br_action_list_up () {
    action='branch';

    case "${1}" in
        '-l'|'-local'|'-list')
            pointer='-l';
            ;;
        '-r'|'-remote')
            pointer='-r';
            ;;
        '-a'|'-all')
            pointer='-a';
            ;;
    esac
}

__gi_br_action_delete_up () {
    case "${1}" in
        '-l'|'-local'|'')
            action='branch -D';
            __gi_br_helper_pointer "${2}";
            question="Are you sure you want to remove $(dye orange)${pointer}$(dye undye) locally?";

            ;;
        '-o'|'-r'|'-origin'|'-remote')
            action='push origin --delete';
            __gi_br_helper_pointer "${2}" 'detect';
            question="Are you REALLY sure you want to remove $(dye red)${pointer}$(dye undye) FROM REMOTE?";

            ;;
    esac
}

__gi_br_helper_pointer () {
    if [[ -n "${1}" ]]; then
        pointer="${1}";
    elif [[ "${2}" == 'detect' && "$(get_git_branch)" != 'master' ]]; then
        pointer="$(get_git_branch)";
    else
        error='Pointer missing for this operation';
    fi
}

__gi_br_action_checkout () {
    action='checkout';
    pointer="${1}";
}

## GICM FUNCTIONS
__gicm_action_setup () {
    case "${firstAction}" in
        # Creating a new commit with the common standard
        '-m'|'-message')
            # Only ${firstPointer} is necessary here
            __gicm_action_commit "${firstPointer}";
            ;;
        # Creating a new commit and setting a prefix
        '-p'|'-prefix')
            # Only ${firstPointer} is necessary here
            __gicm_action_set_commit_prefix "${firstPointer}";
            ;;
        '-l'|'-last')
            # Only ${firstAction} is necessary here
            __gicm_action_get_commit_last;
            ;;
        *)
            # Super commit reading a prefix if it exists
            if [[ -z "${firstAction}" && -n "${firstPointer}" ]]; then
                # Only ${firstPointer} is necessary here
                __gicm_action_commit_prefix "${firstPointer}";
            else
                # @TODO - gicm without parameters will output usage
                echo 'eitas';
            fi

            ;;
    esac
}

function __gicm_action_commit() {
    if [ -n "${1}" ]; then
        GICM_COMMIT_LAST="${1}";

        action='commit -m';
        pointer="\"${1}\"";
    else
        error='missing pointer';
    fi

#    echo "${action} ${pointer}";
}

function __gicm_action_set_commit_prefix() {
    if [ -n "${1}" ]; then
        GICM_COMMIT_PREFIX="${1}";

        __gicm_action_commit "${GICM_COMMIT_PREFIX}";
    else
        error='missing pointer';
    fi

#    echo "${GICM_COMMIT_PREFIX}";
}

function __gicm_action_commit_prefix() {
    if [ -n "${1}" ]; then
        local adaptedMessage='';
        if [ -n "${GICM_COMMIT_PREFIX}" ]; then
            adaptedMessage="${GICM_COMMIT_PREFIX} (${1})";
        else
            adaptedMessage="${1}";
        fi

        __gicm_action_commit "${adaptedMessage}";
    else
        error='missing pointer';
    fi
}

function __gicm_action_get_commit_last() {
    if [ -n "${GICM_COMMIT_LAST}" ]; then
        __gicm_action_commit "${GICM_COMMIT_LAST}";
    else
        error='No commits were found';
    fi
}